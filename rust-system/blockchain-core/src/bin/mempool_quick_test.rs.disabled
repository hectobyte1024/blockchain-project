use blockchain_core::{
    Hash256,
    transaction::{Transaction, TransactionInput, TransactionOutput},
    mempool::{Mempool, MempoolConfig, 
        TransactionPriority, ThreadSafeMempool
    },
    BlockchainError,
};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("ðŸ”„ Mempool & Transaction Processing Quick Test");
    println!("==============================================");
    
    // Create mempool with relaxed configuration for testing
    let mut config = MempoolConfig::default();
    config.min_relay_fee_rate = 10; // Very low for testing
    
    let mut mempool = Mempool::new(config);
    
    println!("\nâœ… Test 1: Basic Operations");
    
    // Create simple test transaction
    let tx1 = Transaction::new(
        1,
        vec![TransactionInput::new(Hash256Wrapper::from_hash256(&[1u8; 32]), 0, vec![0u8; 50])], // 50 byte script
        vec![TransactionOutput::create_p2pkh(50_000_000, "test1").unwrap()], // 0.5 coins
    );
    
    let tx2 = Transaction::new(
        1,
        vec![TransactionInput::new(Hash256Wrapper::from_hash256(&[2u8; 32]), 0, vec![0u8; 100])], // 100 byte script  
        vec![TransactionOutput::create_p2pkh(25_000_000, "test2").unwrap()], // 0.25 coins (higher fee)
    );
    
    // Add transactions
    match mempool.add_transaction(tx1.clone()).await {
        Ok(hash) => println!("   âœ“ Added transaction 1: {}", hex::encode(&hash[0..8])),
        Err(e) => println!("   âœ— Failed to add transaction 1: {}", e),
    }
    
    match mempool.add_transaction(tx2.clone()).await {
        Ok(hash) => println!("   âœ“ Added transaction 2: {}", hex::encode(&hash[0..8])),
        Err(e) => println!("   âœ— Failed to add transaction 2: {}", e),
    }
    
    println!("   Transaction count: {}", mempool.transaction_count());
    println!("   Memory usage: {} bytes", mempool.memory_usage());
    
    // Test block construction
    println!("\nâœ… Test 2: Block Construction");
    let block_txs = mempool.get_transactions_for_block(1_000_000);
    println!("   Selected {} transactions for block", block_txs.len());
    
    for (i, tx) in block_txs.iter().enumerate() {
        let fee = 100_000_000 - tx.outputs[0].value; // Simple fee calculation
        println!("     {}. Fee: {} satoshis", i + 1, fee);
    }
    
    // Test statistics
    println!("\nâœ… Test 3: Statistics");
    let stats = mempool.get_stats();
    println!("   Transaction count: {}", stats.transaction_count);
    println!("   Memory usage: {} bytes", stats.memory_usage);
    println!("   Average fee rate: {} sat/byte", stats.avg_fee_rate);
    
    // Test thread-safe wrapper
    println!("\nâœ… Test 4: Thread-Safe Operations");
    let ts_mempool = ThreadSafeMempool::new(MempoolConfig::default());
    
    let tx3 = Transaction::new(
        1,
        vec![TransactionInput::new(Hash256Wrapper::from_hash256(&[3u8; 32]), 0, vec![0u8; 75])],
        vec![TransactionOutput::create_p2pkh(10_000_000, "test3").unwrap()], // Very high fee
    );
    
    match ts_mempool.add_transaction(tx3).await {
        Ok(hash) => println!("   âœ“ Added to thread-safe mempool: {}", hex::encode(&hash[0..8])),
        Err(e) => println!("   âœ— Failed to add to thread-safe mempool: {}", e),
    }
    
    let ts_stats = ts_mempool.get_stats().await;
    println!("   Thread-safe mempool count: {}", ts_stats.transaction_count);
    
    // Test maintenance
    println!("\nâœ… Test 5: Maintenance");
    
    // Create mempool with short transaction age for testing
    let mut short_config = MempoolConfig::default();
    short_config.max_transaction_age = Duration::from_millis(100);
    short_config.min_relay_fee_rate = 10;
    
    let mut temp_mempool = Mempool::new(short_config);
    
    let tx4 = Transaction::new(
        1,
        vec![TransactionInput::new(Hash256Wrapper::from_hash256(&[4u8; 32]), 0, vec![0u8; 50])],
        vec![TransactionOutput::create_p2pkh(80_000_000, "temp").unwrap()],
    );
    
    if let Ok(_) = temp_mempool.add_transaction(tx4).await {
        println!("   Added temporary transaction");
    }
    
    println!("   Transaction count before maintenance: {}", temp_mempool.transaction_count());
    
    // Wait for transaction to age
    sleep(Duration::from_millis(150)).await;
    
    // Run maintenance
    temp_mempool.maintenance().await.unwrap();
    
    println!("   Transaction count after maintenance: {}", temp_mempool.transaction_count());
    
    println!("\nðŸŽ‰ Mempool Quick Test Complete!");
    println!("   âœ“ Basic operations working");
    println!("   âœ“ Block construction working"); 
    println!("   âœ“ Statistics collection working");
    println!("   âœ“ Thread-safe operations working");
    println!("   âœ“ Maintenance working");
    println!("\nðŸš€ Mempool ready for blockchain integration!");
}