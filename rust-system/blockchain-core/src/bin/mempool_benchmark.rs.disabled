use blockchain_core::{
    transaction::{Transaction, TransactionInput, TransactionOutput},
    mempool::{Mempool, MempoolConfig, ThreadSafeMempool, RemovalReason},
};
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("ðŸš€ Mempool Performance Benchmark");
    println!("=================================");
    
    // Benchmark 1: High-throughput transaction addition
    println!("\nðŸ“Š Benchmark 1: Transaction Addition Throughput");
    benchmark_transaction_addition().await;
    
    // Benchmark 2: Priority ordering performance
    println!("\nðŸ“Š Benchmark 2: Priority Ordering Performance");
    benchmark_priority_ordering().await;
    
    // Benchmark 3: Block construction efficiency
    println!("\nðŸ“Š Benchmark 3: Block Construction Efficiency");
    benchmark_block_construction().await;
    
    // Benchmark 4: Memory usage optimization
    println!("\nðŸ“Š Benchmark 4: Memory Usage Optimization");
    benchmark_memory_usage().await;
    
    // Benchmark 5: Concurrent access performance
    println!("\nðŸ“Š Benchmark 5: Concurrent Access Performance");
    benchmark_concurrent_access().await;
    
    println!("\nðŸŽ¯ Mempool Performance Summary:");
    println!("   âœ“ High-throughput transaction processing");
    println!("   âœ“ Efficient priority-based ordering");
    println!("   âœ“ Fast block construction");
    println!("   âœ“ Optimized memory usage");
    println!("   âœ“ Thread-safe concurrent operations");
    println!("\nðŸŽ‰ Mempool ready for production blockchain workloads!");
}

async fn benchmark_transaction_addition() {
    let mut config = MempoolConfig::default();
    config.min_relay_fee_rate = 1; // Very low for benchmarking
    config.max_transactions = 10000; // Allow more transactions
    
    let mut mempool = Mempool::new(config);
    
    let transaction_count = 1000;
    println!("   Adding {} transactions...", transaction_count);
    
    let start_time = Instant::now();
    let mut successful_additions = 0;
    
    for i in 0..transaction_count {
        let tx = create_benchmark_transaction(i, 50_000_000 + i * 1000, "bench");
        if mempool.add_transaction(tx).await.is_ok() {
            successful_additions += 1;
        }
    }
    
    let elapsed = start_time.elapsed();
    let throughput = successful_additions as f64 / elapsed.as_secs_f64();
    
    println!("   Successfully added: {}/{} transactions", successful_additions, transaction_count);
    println!("   Time taken: {:?}", elapsed);
    println!("   Throughput: {:.2} transactions/second", throughput);
    println!("   Memory usage: {} bytes", mempool.memory_usage());
    
    let stats = mempool.get_stats();
    println!("   Average fee rate: {} sat/byte", stats.avg_fee_rate);
    println!("   Min fee rate: {} sat/byte", stats.min_fee_rate);
    println!("   Max fee rate: {} sat/byte", stats.max_fee_rate);
}

async fn benchmark_priority_ordering() {
    let mut config = MempoolConfig::default();
    config.min_relay_fee_rate = 1;
    
    let mut mempool = Mempool::new(config);
    
    // Add transactions with varying fee rates
    let transaction_count = 500;
    println!("   Adding {} transactions with varying priorities...", transaction_count);
    
    for i in 0..transaction_count {
        // Create transactions with different fee structures
        let output_value = if i % 4 == 0 {
            10_000_000  // High fee (90M fee)
        } else if i % 4 == 1 {
            50_000_000  // Medium fee (50M fee)
        } else if i % 4 == 2 {
            80_000_000  // Low fee (20M fee)
        } else {
            5_000_000   // Very high fee (95M fee)
        };
        
        let tx = create_benchmark_transaction(i, output_value, "priority");
        let _ = mempool.add_transaction(tx).await;
    }
    
    // Benchmark block construction (priority ordering)
    let start_time = Instant::now();
    let block_txs = mempool.get_transactions_for_block(1_000_000); // 1MB block
    let elapsed = start_time.elapsed();
    
    println!("   Block construction time: {:?}", elapsed);
    println!("   Selected {} transactions for block", block_txs.len());
    
    // Verify ordering (higher fees should come first)
    let mut fees: Vec<u64> = block_txs.iter()
        .map(|tx| 100_000_000 - tx.outputs[0].value)
        .collect();
    
    let mut sorted_fees = fees.clone();
    sorted_fees.sort_by(|a, b| b.cmp(a)); // Sort descending
    
    let correctly_ordered = fees == sorted_fees;
    println!("   Transactions correctly ordered by fee: {}", correctly_ordered);
    
    if block_txs.len() >= 5 {
        println!("   Top 5 transaction fees:");
        for i in 0..5 {
            let fee = 100_000_000 - block_txs[i].outputs[0].value;
            println!("     {}. {} satoshis", i + 1, fee);
        }
    }
}

async fn benchmark_block_construction() {
    let mut config = MempoolConfig::default();
    config.min_relay_fee_rate = 1;
    
    let mut mempool = Mempool::new(config);
    
    // Add a large number of transactions
    let transaction_count = 2000;
    println!("   Populating mempool with {} transactions...", transaction_count);
    
    for i in 0..transaction_count {
        let tx = create_benchmark_transaction(i, 50_000_000 + (i % 1000) * 1000, "block");
        let _ = mempool.add_transaction(tx).await;
    }
    
    // Benchmark multiple block constructions
    let block_constructions = 100;
    let block_sizes = [100_000, 500_000, 1_000_000]; // Different block sizes
    
    println!("   Running {} block constructions for each size...", block_constructions);
    
    for &block_size in &block_sizes {
        let start_time = Instant::now();
        
        for _ in 0..block_constructions {
            let _block_txs = mempool.get_transactions_for_block(block_size);
        }
        
        let elapsed = start_time.elapsed();
        let avg_time = elapsed / block_constructions;
        let constructions_per_sec = 1.0 / avg_time.as_secs_f64();
        
        println!("   Block size {}: {:.2} constructions/sec (avg: {:?})", 
                 format_bytes(block_size), constructions_per_sec, avg_time);
    }
}

async fn benchmark_memory_usage() {
    let mut config = MempoolConfig::default();
    config.min_relay_fee_rate = 1;
    config.max_memory_usage = 50 * 1024 * 1024; // 50MB limit
    
    let mut mempool = Mempool::new(config);
    
    println!("   Testing memory usage with limit of 50MB...");
    
    let mut transactions_added = 0;
    let mut total_memory = 0;
    
    // Keep adding transactions until memory limit
    for i in 0..10000 {
        let tx = create_large_transaction(i, "memory_test");
        
        if mempool.add_transaction(tx).await.is_ok() {
            transactions_added += 1;
            total_memory = mempool.memory_usage();
            
            // Report every 100 transactions
            if transactions_added % 100 == 0 {
                println!("     {} transactions: {} memory", 
                         transactions_added, format_bytes(total_memory));
            }
            
            // Stop if we're getting close to limit
            if total_memory > 45 * 1024 * 1024 {
                break;
            }
        } else {
            break; // Hit memory limit or transaction limit
        }
    }
    
    let stats = mempool.get_stats();
    println!("   Final statistics:");
    println!("     Transactions: {}", transactions_added);
    println!("     Memory usage: {}", format_bytes(total_memory));
    println!("     Average transaction size: {:.2} bytes", 
             total_memory as f64 / transactions_added as f64);
    println!("     Memory efficiency: {:.2}%", 
             (stats.memory_usage as f64 / (50 * 1024 * 1024) as f64) * 100.0);
}

async fn benchmark_concurrent_access() {
    let mempool = std::sync::Arc::new(ThreadSafeMempool::new(MempoolConfig {
        min_relay_fee_rate: 1,
        max_transactions: 5000,
        ..Default::default()
    }));
    
    let concurrent_tasks = 10;
    let transactions_per_task = 100;
    
    println!("   Running {} concurrent tasks, {} transactions each...", 
             concurrent_tasks, transactions_per_task);
    
    let start_time = Instant::now();
    let mut handles = vec![];
    
    // Spawn concurrent tasks
    for task_id in 0..concurrent_tasks {
        let mempool_clone = mempool.clone();
        let handle = tokio::spawn(async move {
            let mut successful = 0;
            
            for i in 0..transactions_per_task {
                let tx_id = task_id * transactions_per_task + i;
                let tx = create_benchmark_transaction(tx_id as u64, 
                                                   50_000_000 + tx_id * 1000, 
                                                   &format!("concurrent_{}", task_id));
                
                if mempool_clone.add_transaction(tx).await.is_ok() {
                    successful += 1;
                }
                
                // Small delay to simulate real-world usage
                if i % 10 == 0 {
                    sleep(Duration::from_micros(100)).await;
                }
            }
            
            successful
        });
        handles.push(handle);
    }
    
    // Wait for all tasks to complete
    let mut total_successful = 0;
    for handle in handles {
        if let Ok(successful) = handle.await {
            total_successful += successful;
        }
    }
    
    let elapsed = start_time.elapsed();
    let throughput = total_successful as f64 / elapsed.as_secs_f64();
    
    let final_stats = mempool.get_stats().await;
    
    println!("   Concurrent benchmark results:");
    println!("     Total transactions attempted: {}", concurrent_tasks * transactions_per_task);
    println!("     Successfully added: {}", total_successful);
    println!("     Time taken: {:?}", elapsed);
    println!("     Concurrent throughput: {:.2} tx/sec", throughput);
    println!("     Final mempool size: {}", final_stats.transaction_count);
    println!("     Memory usage: {}", format_bytes(final_stats.memory_usage));
}

fn create_benchmark_transaction(id: u64, output_value: u64, prefix: &str) -> Transaction {
    let mut input_hash = [0u8; 32];
    input_hash[0] = (id % 256) as u8;
    input_hash[1] = ((id >> 8) % 256) as u8;
    input_hash[2] = ((id >> 16) % 256) as u8;
    input_hash[3] = ((id >> 24) % 256) as u8;
    
    // Variable script size for different fee rates
    let script_size = 50 + (id % 100) as usize;
    let script_sig = vec![0u8; script_size];
    
    Transaction::new(
        1,
        vec![TransactionInput::new(Hash256Wrapper::from_hash256(&input_hash), id as u32 % 1000, script_sig)],
        vec![TransactionOutput::create_p2pkh(output_value, &format!("{}_{}", prefix, id)).unwrap()],
    )
}

fn create_large_transaction(id: u64, prefix: &str) -> Transaction {
    let mut input_hash = [0u8; 32];
    input_hash[0] = (id % 256) as u8;
    input_hash[1] = ((id >> 8) % 256) as u8;
    
    // Large script to test memory usage
    let script_sig = vec![0u8; 200 + (id % 300) as usize];
    
    Transaction::new(
        1,
        vec![TransactionInput::new(Hash256Wrapper::from_hash256(&input_hash), id as u32, script_sig)],
        vec![TransactionOutput::create_p2pkh(50_000_000, &format!("{}_{}", prefix, id)).unwrap()],
    )
}

fn format_bytes(bytes: usize) -> String {
    if bytes >= 1024 * 1024 {
        format!("{:.2} MB", bytes as f64 / (1024.0 * 1024.0))
    } else if bytes >= 1024 {
        format!("{:.2} KB", bytes as f64 / 1024.0)
    } else {
        format!("{} bytes", bytes)
    }
}