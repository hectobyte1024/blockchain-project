//! High-performance async P2P networking layer for blockchain
//!\n//! This module provides the networking infrastructure for the hybrid blockchain,\n//! leveraging Rust's async capabilities while integrating with the C++ core engine.\n\npub mod peer;\npub mod protocol;\npub mod discovery;\npub mod message;\npub mod swarm;\n\nuse serde::{Deserialize, Serialize};\nuse std::{\n    collections::HashMap,\n    net::SocketAddr,\n    time::Duration,\n};\nuse tokio::sync::{mpsc, RwLock};\nuse tracing::{info, warn, error};\n\n/// Network configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkConfig {\n    /// Local listening address\n    pub listen_addr: SocketAddr,\n    /// Maximum number of peers\n    pub max_peers: usize,\n    /// Connection timeout\n    pub connection_timeout: Duration,\n    /// Heartbeat interval\n    pub heartbeat_interval: Duration,\n    /// Maximum message size\n    pub max_message_size: usize,\n    /// Network magic bytes (mainnet/testnet)\n    pub network_magic: u32,\n    /// DNS seed nodes for bootstrapping\n    pub dns_seeds: Vec<String>,\n    /// Known peer addresses\n    pub seed_peers: Vec<SocketAddr>,\n}\n\nimpl Default for NetworkConfig {\n    fn default() -> Self {\n        Self {\n            listen_addr: \"0.0.0.0:8333\".parse().unwrap(),\n            max_peers: 125,\n            connection_timeout: Duration::from_secs(10),\n            heartbeat_interval: Duration::from_secs(30),\n            max_message_size: 32 * 1024 * 1024, // 32MB\n            network_magic: 0xD9B4BEF9, // Mainnet magic\n            dns_seeds: vec![\n                \"seed.bitcoin.sipa.be\".to_string(),\n                \"dnsseed.bluematt.me\".to_string(),\n                \"seed.bitcoinstats.com\".to_string(),\n            ],\n            seed_peers: vec![],\n        }\n    }\n}\n\n/// Network event types\n#[derive(Debug, Clone)]\npub enum NetworkEvent {\n    /// New peer connected\n    PeerConnected {\n        peer_id: String,\n        addr: SocketAddr,\n    },\n    /// Peer disconnected\n    PeerDisconnected {\n        peer_id: String,\n        reason: String,\n    },\n    /// Message received from peer\n    MessageReceived {\n        peer_id: String,\n        message: protocol::Message,\n    },\n    /// Failed to send message\n    MessageSendFailed {\n        peer_id: String,\n        error: String,\n    },\n}\n\n/// Network statistics\n#[derive(Debug, Default, Clone, Serialize, Deserialize)]\npub struct NetworkStats {\n    /// Number of connected peers\n    pub connected_peers: usize,\n    /// Total bytes sent\n    pub bytes_sent: u64,\n    /// Total bytes received  \n    pub bytes_received: u64,\n    /// Total messages sent\n    pub messages_sent: u64,\n    /// Total messages received\n    pub messages_received: u64,\n    /// Connection attempts\n    pub connection_attempts: u64,\n    /// Failed connections\n    pub failed_connections: u64,\n}\n\n/// Network error types\n#[derive(Debug, thiserror::Error)]\npub enum NetworkError {\n    #[error(\"Connection failed: {0}\")]\n    ConnectionFailed(String),\n    \n    #[error(\"Invalid message: {0}\")]\n    InvalidMessage(String),\n    \n    #[error(\"Peer not found: {0}\")]\n    PeerNotFound(String),\n    \n    #[error(\"Network timeout\")]\n    Timeout,\n    \n    #[error(\"Invalid address: {0}\")]\n    InvalidAddress(String),\n    \n    #[error(\"Protocol error: {0}\")]\n    ProtocolError(String),\n    \n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n    \n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n}\n\npub type Result<T> = std::result::Result<T, NetworkError>;\n\n/// Main network manager that coordinates P2P operations\npub struct NetworkManager {\n    config: NetworkConfig,\n    peers: RwLock<HashMap<String, peer::Peer>>,\n    stats: RwLock<NetworkStats>,\n    event_tx: mpsc::UnboundedSender<NetworkEvent>,\n    swarm: swarm::NetworkSwarm,\n}\n\nimpl NetworkManager {\n    /// Create new network manager\n    pub fn new(\n        config: NetworkConfig,\n        event_tx: mpsc::UnboundedSender<NetworkEvent>,\n    ) -> Result<Self> {\n        let swarm = swarm::NetworkSwarm::new(&config)?;\n        \n        Ok(Self {\n            config,\n            peers: RwLock::new(HashMap::new()),\n            stats: RwLock::new(NetworkStats::default()),\n            event_tx,\n            swarm,\n        })\n    }\n    \n    /// Start the network manager\n    pub async fn start(&self) -> Result<()> {\n        info!(\"Starting network manager on {}\", self.config.listen_addr);\n        \n        // Start listening for incoming connections\n        self.swarm.start_listening(&self.config.listen_addr).await?;\n        \n        // Bootstrap from DNS seeds\n        self.bootstrap().await?;\n        \n        // Start background tasks\n        self.start_background_tasks().await;\n        \n        info!(\"Network manager started successfully\");\n        Ok(())\n    }\n    \n    /// Bootstrap network connections from seeds\n    async fn bootstrap(&self) -> Result<()> {\n        info!(\"Bootstrapping network connections...\");\n        \n        // Connect to seed peers\n        for addr in &self.config.seed_peers {\n            if let Err(e) = self.connect_to_peer(*addr).await {\n                warn!(\"Failed to connect to seed peer {}: {}\", addr, e);\n            }\n        }\n        \n        // Discover peers from DNS seeds\n        for dns_seed in &self.config.dns_seeds {\n            if let Err(e) = self.discover_peers_from_dns(dns_seed).await {\n                warn!(\"Failed to discover peers from DNS seed {}: {}\", dns_seed, e);\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Connect to a specific peer\n    pub async fn connect_to_peer(&self, addr: SocketAddr) -> Result<String> {\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        \n        match self.swarm.connect_to_peer(addr).await {\n            Ok(peer_id) => {\n                info!(\"Successfully connected to peer {} at {}\", peer_id, addr);\n                \n                // Send network event\n                let _ = self.event_tx.send(NetworkEvent::PeerConnected {\n                    peer_id: peer_id.clone(),\n                    addr,\n                });\n                \n                Ok(peer_id)\n            }\n            Err(e) => {\n                stats.failed_connections += 1;\n                warn!(\"Failed to connect to peer at {}: {}\", addr, e);\n                Err(e)\n            }\n        }\n    }\n    \n    /// Disconnect from a peer\n    pub async fn disconnect_from_peer(&self, peer_id: &str, reason: &str) -> Result<()> {\n        info!(\"Disconnecting from peer {}: {}\", peer_id, reason);\n        \n        // Remove from peer list\n        let mut peers = self.peers.write().await;\n        peers.remove(peer_id);\n        \n        // Disconnect from swarm\n        self.swarm.disconnect_from_peer(peer_id).await?;\n        \n        // Send network event\n        let _ = self.event_tx.send(NetworkEvent::PeerDisconnected {\n            peer_id: peer_id.to_string(),\n            reason: reason.to_string(),\n        });\n        \n        Ok(())\n    }\n    \n    /// Send message to a specific peer\n    pub async fn send_message_to_peer(\n        &self,\n        peer_id: &str,\n        message: protocol::Message,\n    ) -> Result<()> {\n        match self.swarm.send_message_to_peer(peer_id, message).await {\n            Ok(_) => {\n                let mut stats = self.stats.write().await;\n                stats.messages_sent += 1;\n                Ok(())\n            }\n            Err(e) => {\n                let _ = self.event_tx.send(NetworkEvent::MessageSendFailed {\n                    peer_id: peer_id.to_string(),\n                    error: e.to_string(),\n                });\n                Err(e)\n            }\n        }\n    }\n    \n    /// Broadcast message to all connected peers\n    pub async fn broadcast_message(&self, message: protocol::Message) -> Result<()> {\n        let peers = self.peers.read().await;\n        let mut sent_count = 0;\n        \n        for peer_id in peers.keys() {\n            if self.send_message_to_peer(peer_id, message.clone()).await.is_ok() {\n                sent_count += 1;\n            }\n        }\n        \n        info!(\"Broadcasted message to {} peers\", sent_count);\n        Ok(())\n    }\n    \n    /// Get current network statistics\n    pub async fn get_stats(&self) -> NetworkStats {\n        let stats = self.stats.read().await;\n        let peers = self.peers.read().await;\n        \n        let mut result = stats.clone();\n        result.connected_peers = peers.len();\n        result\n    }\n    \n    /// Get list of connected peers\n    pub async fn get_connected_peers(&self) -> Vec<String> {\n        let peers = self.peers.read().await;\n        peers.keys().cloned().collect()\n    }\n    \n    /// Discover peers from DNS seed\n    async fn discover_peers_from_dns(&self, dns_seed: &str) -> Result<()> {\n        // This would perform DNS lookups to find peer addresses\n        // For now, return placeholder implementation\n        info!(\"Discovering peers from DNS seed: {}\", dns_seed);\n        Ok(())\n    }\n    \n    /// Start background maintenance tasks\n    async fn start_background_tasks(&self) {\n        // Heartbeat task\n        let heartbeat_interval = self.config.heartbeat_interval;\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(heartbeat_interval);\n            loop {\n                interval.tick().await;\n                // Send ping messages to peers to keep connections alive\n                // TODO: Implement heartbeat logic\n            }\n        });\n        \n        // Peer discovery task\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(300)); // 5 minutes\n            loop {\n                interval.tick().await;\n                // Periodically discover new peers\n                // TODO: Implement peer discovery logic\n            }\n        });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tokio::sync::mpsc;\n    \n    #[tokio::test]\n    async fn test_network_manager_creation() {\n        let config = NetworkConfig::default();\n        let (event_tx, _event_rx) = mpsc::unbounded_channel();\n        \n        let manager = NetworkManager::new(config, event_tx);\n        assert!(manager.is_ok());\n    }\n    \n    #[tokio::test]\n    async fn test_network_stats() {\n        let config = NetworkConfig::default();\n        let (event_tx, _event_rx) = mpsc::unbounded_channel();\n        \n        let manager = NetworkManager::new(config, event_tx).unwrap();\n        let stats = manager.get_stats().await;\n        \n        assert_eq!(stats.connected_peers, 0);\n        assert_eq!(stats.messages_sent, 0);\n    }\n}"